{"meta":{"title":"IMCSI","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-03-23T07:43:23.000Z","updated":"2018-03-23T07:45:55.664Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"在大学生活快进入尾声的时候，终于开始去想以后的路该怎么走。在大学里并没有学到什么特别有用的东西（也有部分原因是自己没认真学- -）..临近实习的那段时间，无意间就想着做做网站。那时候什么都不懂，什么都不会，自己抱着一本基础的建html页面的课本，慢慢敲慢慢打代码。虽然到后来做的页面的确不怎么好看，但毕竟是自己做的，还是有些成就感的.. 学习来自兴趣，早已抛弃认真态度的学习方式，想要再重新找回学习的热情，除了一步一个脚印，没有更快的方法。 生活也是一个获得与失去的过程，有获得的喜悦，也有失去的忧伤，只有当自己深切去体会，才知道美好生活来之不易。尽管在学习的道路上还有很长的路要走，但唯有坚持，才是最重要的。也希望在看这段话的你，也能够坚持自己的理想，不抛弃，不放弃。 关于博客： 2016.4.11 iBeEasy，即我的个人博客正式上线。使用的是帝国CMS7.2管理系统，而博客模板借用的是杨青个人博客上面的模板，阿里云的虚拟主机以及万网的域名。作为一个新手很难写出写不出一套管理系统，但是又想弄一个博客，然后就自己瞎折腾出来了。 2016.11.20 在此之前，会偶尔更新一些文章（鸡汤）。之后就因为工作上的原因暂停更新。 2017 因为工作的调整，并没有时间来整理博客。 2018.1.8 大概是因为太闲了，又折腾起了博客，除了域名其他的都做了很大的改变，管理系统由帝国CMS更换到WordPress（用的人多），模板是由网站名而找到的easyblog模板，简单，随心。鉴于前面做的第一个博客，本博客的文章将以技术为主，方便总结以及复习。"}],"posts":[{"title":"Lavaral使用（5）","slug":"Lavaral使用（5）","date":"2018-03-23T06:54:51.000Z","updated":"2018-03-23T08:03:09.192Z","comments":true,"path":"2018/03/23/Lavaral使用（5）/","link":"","permalink":"http://yoursite.com/2018/03/23/Lavaral使用（5）/","excerpt":"","text":"1,Cache的使用Laravel目前支持流行的缓存后端包括Memcached和Redis等，下面说的是数据库缓存： 使用database缓存驱动时，你需要设置一张表包含缓存缓存项。下面是该表的Schema声明： Schema::create(&apos;cache&apos;, function (Blueprint $table) { $table-&gt;string(&apos;key&apos;)-&gt;unique(); $table-&gt;text(&apos;value&apos;); $table-&gt;integer(&apos;expiration&apos;); }); 首先创建表迁移： php artisan make:migration create_cache_table 再将表迁移内容替换进去，就是第一段替换 执行表迁移： PS E:\\wamp\\www\\blog&gt; php artisan migrate Migrating: 2018_03_22_160436_create_cache_table Migrated: 2018_03_22_160436_create_cache_table 那么就可以使用数据库缓存了 在需要使用的控制器里使用： use Cache； 比如要将文章的详情页存入到数据库缓存，并且在没有该详情页缓存的时候添加进去： public function show($id) { $result[&apos;result&apos;] = Cache::remember(&apos;news_&apos; . $id, 10060, function () use ($id) {//news_$id用于区分不同的文章详情，10060表示缓存时间，单位分， 后面是缓存内容，使用闭包函数use连接文章id调用模型来获取数据 return Index::where(&apos;id&apos;, $id)-&gt;first(); }); $result[&apos;category_id&apos;] = $result[&apos;result&apos;][&apos;category_id&apos;]; return view(&apos;home.index.show&apos;, $result); } Cache的remember方法第一个参数代表的是缓存的key，第二个参数代表缓存的时间，第三个参数表示的是在没有该key的情况下设置的默认值，该参数支持闭包函数。 你也可使用remember和forever方法： $value = Cache::rememberForever(&apos;news_&apos; . $id,function () use ($id) { return Index::where(&apos;id&apos;, $id)-&gt;first();}); 来永久缓存数据。 扩展：比如一些导航栏是每个页面都要获取，我们也可以将其加入到缓存中： 在之前的文章里，公用的数据我们都放在app/Providers/目录下的服务提供者文件里统一加载数据。 首先在服务提供者的文件里： public function boot() { //基于闭包的composer view()-&gt;composer(&apos;layouts.home&apos;, function ($view) { $config = DB::table(&apos;config&apos;)//获取网站的全局配置参数，如客服电话，公司地址等。。 -&gt;where(&apos;id&apos;, 1) -&gt;first(); $banner = DB::table(&apos;image&apos;) -&gt;where(&apos;is_see&apos;, 1) -&gt;get(); $view-&gt;with(&apos;config&apos;, $config)-&gt;with(&apos;banner&apos;, $banner); }); } 将站点配置$config和$banner加入到缓存中： public function boot() { //基于闭包的composer view()-&gt;composer(&apos;layouts.home&apos;, function ($view) { $config = Cache::remember(&apos;config&apos;, 10060, function () {//获取key=config的数据，如果没有则使用闭包函数从数据库获取并存入缓存 return DB::table(&apos;config&apos;)-&gt;where(&apos;id&apos;, 1)-&gt;first(); }); $banner = Cache::remember(&apos;banner&apos;, 10060, function () { return DB::table(&apos;image&apos;)-&gt;where(&apos;is_see&apos;, 1)-&gt;get(); }); $view-&gt;with(&apos;config&apos;, $config)-&gt;with(&apos;banner&apos;, $banner); }); } 那么在第一次访问的时候借用laravel-debugbar调试器是这样的： 当第二次访问的时候： 因为之前的全局数据以及文章详情都存入到了缓存中，所以没有查询数据库。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"cache","slug":"cache","permalink":"http://yoursite.com/tags/cache/"}]},{"title":"Lavaral使用（4）","slug":"Lavaral使用（4）","date":"2018-03-23T06:54:47.000Z","updated":"2018-03-23T08:03:01.225Z","comments":true,"path":"2018/03/23/Lavaral使用（4）/","link":"","permalink":"http://yoursite.com/2018/03/23/Lavaral使用（4）/","excerpt":"","text":"1.多视图共享数据如题，如果我们有一些固定的网站内容，如联系方式，客服扣扣等，需要放在公用视图模板的头部或底部，如这样： 在home.blade.php中 &lt;p&gt;手机：{{$config->linktel}} 丨 邮箱：{{$config->linkemail}} 丨 地址：{{$config->linkadress}}&lt;/p&gt; 怎样在每个视图中都加载这些内容呢。 1.直接使用View::share()方法来在每个视图层加载固定内容 首先使用Artisan创建服务提供者 php artisan make:provider ComposerServiceProvider 然后在config/app.php里注册提供者。在providers里加入： &apos;providers&apos; =&gt; [ /* * Laravel Framework Service Providers... */ Illuminate\\Auth\\AuthServiceProvider::class, Illuminate\\Broadcasting\\BroadcastServiceProvider::class, ........ App\\Providers\\RouteServiceProvider::class, App\\Providers\\ComposerServiceProvider::class,//加入刚刚创建的提供者 Stevenyangecho\\UEditor\\UEditorServiceProvider::class, ], 然后在注册的提供者里面加入： public function boot() { View::share(&apos;abc&apos;,&apos;beeasy&apos;); } 这是使用外观模式，也可以直接使用view()方法， view()-&gt;share(&apos;abc&apos;, &apos;beeasy&apos;); 这样在视图层里面就能直接使用 {{$abc}} 2.使用Composer单独对某个视图闭包来完成 public function boot() { //基于闭包的composer view()-&gt;composer(&apos;layouts.home&apos;, function ($view) {//绑定公用视图的前端页面 $config = DB::table(&apos;config&apos;) -&gt;where(&apos;id&apos;, 1) -&gt;first(); $view-&gt;with(&apos;config&apos;, $config);//将数据载入到视图 }); } 这样就能在layouts/home.blade.php视图下直接使用config变量了 当然你也可以这样写： public function boot() { //基于闭包的composer view()-&gt;composer(*, function ($view) {//绑定公用视图的前端页面 $config = DB::table(&apos;config&apos;) -&gt;where(&apos;id&apos;, 1) -&gt;first(); $view-&gt;with(&apos;config&apos;, $config);//将数据传递到视图 }); } 这样就能达到第一种方法的效果 两种方法的区别：第一种方法是在每个视图层都传递数据，而第二种是针对某个视图层来传递数据，具体的选择方法还是要根据具体情况来定。 2.安装laravel-debugbar来提高开发效率1). 使用 Composer 安装该扩展包： composer require barryvdh/laravel-debugbar 2). 安装完成后，修改 config/app.php 在 providers 数组内追加 Debugbar 的 Provider &apos;providers&apos; =&gt; [ ... Barryvdh\\Debugbar\\ServiceProvider::class, ], 同时在 aliases 数组内追加如下内容 &apos;aliases&apos; =&gt; [ ... &apos;Debugbar&apos; =&gt; Barryvdh\\Debugbar\\Facade::class, ] 3). 接下来运行以下命令生成此扩展包的配置文件 config/debugbar.php： php artisan vendor:publish --provider=&quot;Barryvdh\\Debugbar\\ServiceProvider&quot; 打开 config/debugbar.php，将 enabled 的值设置为： &apos;enabled&apos; =&gt; env(&apos;APP_DEBUG&apos;, false), 修改完以后, Debugbar 分析器的启动状态将由 .env文件中 APP_DEBUG 值决定。 页面刷新后, 看到下图即表示运行成功。 原文地址：https://laravel-china.org/topics/2531 关闭功能只需要在debugbar.php文件中，将 &apos;enabled&apos; =&gt; env(&apos;APP_DEBUG&apos;, false), 改为 &apos;enabled&apos; =&gt; env(&apos;DEBUGBAR_ENABLED&apos;, false),","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"debugbar","slug":"debugbar","permalink":"http://yoursite.com/tags/debugbar/"}]},{"title":"Lavaral使用（3）","slug":"Lavaral使用（3）","date":"2018-03-23T06:54:43.000Z","updated":"2018-03-23T08:02:33.924Z","comments":true,"path":"2018/03/23/Lavaral使用（3）/","link":"","permalink":"http://yoursite.com/2018/03/23/Lavaral使用（3）/","excerpt":"","text":"1.图片上传直接上代码： use DB; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Storage;//使用到的类 ... public function update(Request $request, $id) {// $data = $request-&gt;except(&apos;_token&apos;);//获取表单中除token外的所有数值 if (!$request-&gt;hasFile(&apos;image&apos;)) {//判断是否有图片上传 DB::table(&apos;image&apos;) -&gt;where(&apos;id&apos;, $id) -&gt;update($data); return redirect(&apos;admin/carousel/index&apos;); } else { $file = $data[&apos;image&apos;];//获取图片信息 $this-&gt;validate($request, [//图片验证 &apos;logo_img&apos; =&gt; &apos;image|between:0,5242880&apos;,//是否为图片类型，以及大小在0~5M之间 ], [ &apos;image&apos; =&gt; &apos;:attribute 必须为图片&apos;, &apos;size&apos; =&gt; &apos;:attribute 文件大小必须小于5M&apos;, ], [ &apos;image&apos; =&gt; &apos;图片&apos;, ]); //判断文件是否上传成功 if ($file-&gt;isValid()) { //原文件名 $originalName = $file-&gt;getClientOriginalName(); //扩展名 $ext = $file-&gt;getClientOriginalExtension(); //MimeType $type = $file-&gt;getClientMimeType(); //临时绝对路径 $realPath = $file-&gt;getRealPath(); $filename = uniqid() . &apos;.&apos; . $ext; $bool = Storage::disk(&apos;public&apos;)-&gt;put($filename, file_get_contents($realPath));//这里使用的是基于PHP的flysystem强大的文件系统抽象 //判断是否上传成功 if ($bool) { $data[&apos;image&apos;] = Storage::disk(&apos;public&apos;)-&gt;url($filename);//获取软连接地址 DB::table(&apos;image&apos;) -&gt;where(&apos;id&apos;, $id) -&gt;update($data); return redirect(&apos;admin/carousel/index&apos;);//存储到数据库 } else { return redirect()-&gt;back()-&gt;with(&apos;msg&apos;, &apos;请稍后再试&apos;); } } } } 我们上传文件的地址其实是在 config/filesystems.php配置文件中的disk数组下public中的root地址 &apos;disks&apos; =&gt; [ &apos;local&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;local&apos;, &apos;root&apos; =&gt; storage_path(&apos;app&apos;), ], &apos;public&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;local&apos;, &apos;root&apos; =&gt; storage_path(&apos;app/public&apos;), &apos;url&apos; =&gt; env(&apos;APP_URL&apos;) . &apos;/storage&apos;, &apos;visibility&apos; =&gt; &apos;public&apos;, ], &apos;s3&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;s3&apos;, &apos;key&apos; =&gt; env(&apos;AWS_ACCESS_KEY_ID&apos;), &apos;secret&apos; =&gt; env(&apos;AWS_SECRET_ACCESS_KEY&apos;), &apos;region&apos; =&gt; env(&apos;AWS_DEFAULT_REGION&apos;), &apos;bucket&apos; =&gt; env(&apos;AWS_BUCKET&apos;), ], ], 因为我们指定的disks是public，所以上传的文件将存储在/storage/app/public目录下。 当以上操作成功将文件上传，我们使用Storage::disk(‘public’)-&gt;url($filename) 获取到的结果是这样的： /storage/5aaa3fe021b6f.png 虽然路径看起来一目了然，但是直接拿到页面上去用并不能获取到图片。 那么我们需要创建一个软连接来将上面的链接指向到storage_path(‘app/public’) 即 /storage/app/public目录下 要创建这个软链接，直接使用Artisan命令： php artisan storage:link 文件被存储并且软链已经被创建的情况下，就可以使用辅助函数 asset 创建一个指向该文件的URL： &lt;img src=&quot;{{ asset(‘/storage/5aaa3fe021b6f.png’) }}&quot;&gt; 这种方式可以将公开访问的文件保存在一个可以很容易被不同部署环境共享的目录，在使用零停机时间部署系统如Envoyer的时候尤其方便。 关于flysystem其他的一些文件操作，可参考http://laravelacademy.org/post/6071.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"上传","slug":"上传","permalink":"http://yoursite.com/tags/上传/"}]},{"title":"Lavaral使用（2）","slug":"Lavaral使用（2）","date":"2018-03-23T06:54:40.000Z","updated":"2018-03-23T08:02:46.536Z","comments":true,"path":"2018/03/23/Lavaral使用（2）/","link":"","permalink":"http://yoursite.com/2018/03/23/Lavaral使用（2）/","excerpt":"","text":"1.富文本编辑器（UEditor）laravel的依赖管理工具composer中可以快速的帮助我们集成ueditor到框架中，配置过程： 在laravel项目根目录配置composer.json文件，在require中写入： &quot;stevenyangecho/laravel-u-editor&quot;: &quot;~1.4&quot; 然后在cmd模式下输入：composer update （需要将composer配置为全局变量） PS E:\\wamp\\www\\blog&gt; composer update Loading composer repositories with package information Updating dependencies (including require-dev) Package operations: 3 installs, 31 updates, 0 removals - Updating symfony/polyfill-mbstring (v1.6.0 =&gt; v1.7.0): Downloading (100%) - Updating symfony/var-dumper (v3.3.13 =&gt; v3.4.6): Downloading (100%) - Updating symfony/debug (v3.3.13 =&gt; v3.4.6): Downloading (100%) .......//省略部分内容 Package manifest generated successfully. 更新完成之后，修改laravel的配置文件（config/app.php）: 在 “providers” 这个key 最后加上 ： Stevenyangecho\\UEditor\\UEditorServiceProvider::class 在”aliases” 这个key最后加上： &apos;UEditor&apos;=&gt;Stevenyangecho\\UEditor\\UEditorServiceProvider::class 配置完之后，命令提示符进入项目的根目录： PS E:\\wamp\\www&gt; cd blog PS E:\\wamp\\www\\blog&gt; php artisan vendor:publish [Symfony\\Component\\Debug\\Exception\\FatalThrowableError] Class &apos;Stevenyangecho\\UEditor\\UEditorServiceProvider&apos; not found 提示以上的错误要确定之前的步骤是否正确： PS E:\\wamp\\www\\blog&gt; php artisan vendor:publish Which provider or tag&apos;s files would you like to publish?: [0 ] Publish files from all providers and tags listed below ....... &gt; 0//输入0 ....... Publishing complete. 出现以上信息说明已经配置完成。 一串文件下载配置之后，laravel项目的public目录下会自动建立一个laravel-u-editor的文件夹。这个文件夹里包含的是编辑器本身的JS文件。同时在config文件夹下也会生成一个名为UEditorUpload.php的文件，这个是基础的配置文件。当这些文件都生成之后，说明编辑器已经在项目中集成好了，下一步就可以在视图文件中进行注入了 前端视图中整合ue编辑器： 首先引入JS等文件，因为laravel框架已经帮我们集成好了，直接在视图文件尾部加入 @include(‘UEditor::head’) 即可 然后加载编辑器的容器，最后实例化编辑器，这部分比较简单，直接贴代码： 加载编辑器的容器 &lt;div id=&quot;detail_info&quot;&gt; &lt;script id=&quot;container&quot; name=&quot;content&quot; type=&quot;text/plain&quot; style=&quot;width: 900px;position:absolute;left:300px;top:120px;&quot;&gt; {!! html_entity_decode($article-&gt;content) !!} //将富文本编辑器内容转义并在页面上显示 &lt;/script&gt; 实例化编辑器 &lt;script&gt; var ue = UE.getEditor(&apos;container&apos;); ue.ready(function(){ ue.execCommand(&apos;serverparam&apos;, &apos;_token&apos;, &apos;{{ csrf_token() }}&apos;); //这里添加laravel安全token：便于数据提交 }); &lt;/script&gt; 2.表单验证直接上代码： public function store(Request $request) { $data = $request-&gt;except(&apos;_token&apos;);//获取除token外的所有表单数据 $this-&gt;validate($request, [//验证表单值 &apos;title&apos; =&gt; &apos;requred&apos;,//设置title为必填 &apos;content&apos; =&gt; &apos;integer&apos;,//设置content整数 ], [ &apos;required&apos; =&gt; &apos;:attribute 为必填项&apos;,//自定义提示文字，默认为英文 &apos;min&apos; =&gt; &apos;:attribute 长度不符合要求&apos;, &apos;integer&apos; =&gt; &apos;:attribute 必须为整数&apos;, ], [ &apos;title&apos; =&gt; &apos;标题&apos;,//设置表单字段表示的含义 &apos;content&apos; =&gt; &apos;内容&apos;, ]);//当验证未通过则自动返回表单页面，不会执行以下内容 $result = DB::table(&apos;news&apos;) -&gt;insert($data);//数据插入 if ($result) { return redirect()-&gt;back()-&gt;with(&apos;msg&apos;, &apos;操作成功&apos;);//插入成功，返回添加页 } else { return redirect()-&gt;back()-&gt;with(&apos;msg&apos;, &apos;操作失败&apos;)-&gt;withInput();//插入失败，返回添加页并提示错误，将原表单数据返回 } } 在页面上显示提示： @if (count($errors) &gt; 0)//$errors 变量在每次请求的所有视图中都可以被使用，你可以很方便的假设 $errors 变量已被定义且进行安全地使用。 &lt;div class=&quot;alert alert-danger&quot;&gt;//验证未通过则返回错误信息 &lt;ul&gt; @foreach ($errors-&gt;all() as $error) &lt;li&gt;{{ $error }}&lt;/li&gt; @endforeach &lt;/ul&gt; &lt;/div&gt; @endif &lt;fieldset&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;资讯标题&lt;/label&gt; {{session('success')}}//此处返回表单验证通过后闪存中session的信息 &lt;div class=&quot;col-sm-6&quot;&gt; &lt;input value=&quot;{{old('title')}}&quot; class=&quot;form-control&quot; id=&quot;title&quot; type=&quot;text&quot; name=&quot;title&quot; style=&quot;width:40%;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; 3.数据筛选和分页 public function index(Request $request) { if ($request-&gt;input(&apos;category_id&apos;)) {//判断是否带有分类id $category_id = $request-&gt;input(&apos;category_id&apos;);//获取分类id if ($category_id == &apos;all&apos;) {//判断是否是所有分类 $news = DB::table(&apos;news&apos;) -&gt;select(&apos;id&apos;, &apos;title&apos;, &apos;category_id&apos;, &apos;addtime&apos;) -&gt;orderBy(&quot;id&quot;, &quot;desc&quot;) -&gt;paginate(10); } else {//否则执行where查询单个分类 $news = DB::table(&apos;news&apos;) -&gt;select(&apos;id&apos;, &apos;title&apos;, &apos;category_id&apos;, &apos;addtime&apos;) -&gt;where(&apos;category_id&apos;, $category_id) -&gt;orderBy(&quot;id&quot;, &quot;desc&quot;) -&gt;paginate(10); } } else {//不带分类id则默认加上，方便在分页里调用 $news = DB::table(&apos;news&apos;) -&gt;select(&apos;id&apos;, &apos;title&apos;, &apos;category_id&apos;, &apos;addtime&apos;) -&gt;orderBy(&quot;id&quot;, &quot;desc&quot;) -&gt;paginate(10); $category_id = &apos;all&apos;; } $category = DB::table(&apos;category&apos;) -&gt;get(); $assign = array( &apos;news&apos; =&gt; $news, &apos;category&apos; =&gt; $category, &apos;category_id&apos; =&gt; $category_id,//用于记住分类id ); return view(&apos;admin.news.index&apos;, $assign); } 重点在于： 默认的分页展示写法是这样的： {!! $news-&gt;links() !!} 那么当分页筛选成功后，点击下一页则无法按照条件筛选，因为category_id没有存入到分页的url。我们需要将分类id加入到分页url中才能记住用户选择的分类id： {!! $news-&gt;appends(array(&apos;category_id&apos;=&gt;$category_id))-&gt;links() !!} 那么生成的分页url是这样的： http://www.blog.com/admin/news/index?category_id=1&amp;page=2 就能记住用户选择的分类id进行where条件筛选。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"UEditor","slug":"UEditor","permalink":"http://yoursite.com/tags/UEditor/"},{"name":"表单验证","slug":"表单验证","permalink":"http://yoursite.com/tags/表单验证/"}]},{"title":"Lavaral使用（1）","slug":"Lavaral使用（1）","date":"2018-03-23T06:54:18.000Z","updated":"2018-03-23T08:01:50.915Z","comments":true,"path":"2018/03/23/Lavaral使用（1）/","link":"","permalink":"http://yoursite.com/2018/03/23/Lavaral使用（1）/","excerpt":"","text":"1.ajax使用ajax传递数据必须带上_token字段: $.ajax({ type:&apos;post&apos;, url:&quot;{{ url('admin/login/login')}} &quot;, data:{username:username,password:password,_token:&apos;&lt;?php echo csrf_token() ?&gt;&apos;}, success:function(data){ if(data==&apos;no&apos;){ $(&apos;#success&apos;).text(&apos;用户名或密码错误&apos;).css(&apos;color&apos;,&apos;red&apos;); }else{ window.location.href=&quot;{{ url('admin/login/login')}}&quot;; } } }) 后台返回ajax数据： public function login(Request $request) { $data = $request-&gt;all(); return response()-&gt;json(&apos;no&apos;); //ajax返回数据 } 2.保存未提交成功的数据 /** * 用户登录验证 */ public function login(Request $request) { $data = $request-&gt;only(&apos;name&apos;, &apos;password&apos;); if (Auth::attempt($data)) { return &apos;ok&apos;; } return redirect(&apos;admin/login/index&apos;)-&gt;withInput($request-&gt;except(&apos;password&apos;))-&gt;with(&apos;msg&apos;, &apos;用户名或密码错误&apos;); //返回登陆页并返回除密码外的所有表单数据，添加一次性session错误提示 } 在视图页用old获取之前的数据 &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;{{ old('username') }}&quot;&gt; {{ session('msg') }} //视图层获取错误信息 3.模板继承比头尾分离更加人性化 制定头尾模板home.blade.php放入resouces/views/layouts/目录下： &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;@yield(&apos;title&apos;) - BeEasy博客&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @yield(&apos;content&apos;) &lt;/body&gt; &lt;/html&gt; 其中变量用@yield()替代 视图层模板继承： @extends(&apos;layouts.home&apos;) @section(&apos;title&apos;, $title); @section(&apos;content&apos;) &lt;form action=&quot;{{ url('view/store') }}&quot; method=&quot;post&quot;&gt; {{ csrf_field() }} &lt;input type=&quot;text&quot; name=&quot;title&quot; value=&quot;&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot;&gt; &lt;br&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; @endsection 其中块级元素必须有闭合标签 4.中间件比如后台管理员登陆后登陆超时将返回登陆 php artisan make:middleware AdminMiddleware 使用Artisan命令快速创建中间件 这个命令会在 app/Http/Middleware 目录下创建一个新的中间件类 Admin来检测用户是否登录 namespace App\\Http\\Middleware; use Closure; use Illuminate\\Support\\Facades\\Auth; class AdminMiddleware { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if (Auth::guard(&apos;admin&apos;)-&gt;check()) {//检测用户是否登录 return $next($request);//执行登陆后的操作。可自行定制 } else { return redirect(&apos;admin/login/index&apos;);//未登录则返回登陆页 } } } 中间件创建成功后我们需要注册中间件，不然使用起来会特别不方便： 在 app/Http/Kernel.php 文件中 protected $routeMiddleware = [ &apos;auth&apos; =&gt; \\Illuminate\\Auth\\Middleware\\Authenticate::class, &apos;auth.basic&apos; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, &apos;bindings&apos; =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, &apos;can&apos; =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, &apos;guest&apos; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, &apos;throttle&apos; =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, &apos;logincheck&apos; =&gt; \\App\\Http\\Middleware\\logincheckMiddleware::class, &apos;admincheck&apos; =&gt; \\App\\Http\\Middleware\\AdminMiddleware::class,//给中间件设置别名，方面调用 ]; 如果你想要中间件在每一个 HTTP 请求期间被执行，只需要将相应的中间件类设置到 app/Http/Kernel.php 的数组属性 $middleware 中即可。 有时候你可能想要通过指定一个键名的方式将相关中间件分到同一个组里面，从而更方便将其分配到路由中，这可以通过使用 HTTP Kernel 的 $middlewareGroups 属性实现。 那么当你将后台登陆页面和登陆成功首页写好后，如何只在登陆成功页加入中间件检测登陆，而不在登陆页加上中间件？ 打开全局路由文件 routes/web.php //admin模块 Route::prefix(&apos;admin&apos;)-&gt;namespace(&apos;admin&apos;)-&gt;group(function () { Route::prefix(&apos;login&apos;)-&gt;group(function () { Route::get(&apos;index&apos;, &apos;LoginController@index&apos;); Route::post(&apos;login&apos;, &apos;LoginController@login&apos;); }); Route::group([&apos;middleware&apos; =&gt; [&apos;admincheck&apos;]], function () { //路由中间件，检测用户是否登录 Route::prefix(&apos;index&apos;)-&gt;group(function () { Route::get(&apos;index&apos;, &apos;IndexController@index&apos;); Route::post(&apos;loginout&apos;, &apos;IndexController@loginout&apos;); }); }); }); 那么其他需要登陆的页面方法，将路由规则写在注释下面就可以了。 5.登陆账号密码验证虽然laravel给我们提供了一套简单的用户注册登录流程，但是并不能完全满足我们的需求，比如我们管理员是在admin表，验证的是username和password。 首先需要在 /config/auth.php文件中添加： &apos;guards&apos; =&gt; [ &apos;web&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;session&apos;, &apos;provider&apos; =&gt; &apos;users&apos;, ], &apos;api&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;token&apos;, &apos;provider&apos; =&gt; &apos;users&apos;, ], &apos;admin&apos; =&gt; [//定义后台的驱动和提供 &apos;driver&apos; =&gt; &apos;session&apos;, &apos;provider&apos; =&gt; &apos;admin&apos;, ], ], 添加配置 &apos;providers&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\\User::class, ], &apos;admin&apos; =&gt; [ //后台驱动以及模型 database驱动对应的是table表单 &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\\Models\\AdminUser::class, ], // &apos;users&apos; =&gt; [ // &apos;driver&apos; =&gt; &apos;database&apos;, // &apos;table&apos; =&gt; &apos;users&apos;, // ], ], 然后我们可以通过复制App目录下User.php &lt;?php namespace App\\Models; use Illuminate\\Foundation\\Auth\\User as Authenticatable; use Illuminate\\Notifications\\Notifiable; class AdminUser extends Authenticatable { use Notifiable; /** * 关联到模型的数据库 */ protected $table = &apos;admin&apos;; /** * The attributes that are mass assignable. * * @var array */ protected $fillable = [//验证的字段 &apos;username&apos;, &apos;password&apos;, ]; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = [ &apos;password&apos;, &apos;remember_token&apos;, ]; } 然后在控制器里调用： public function login(Request $request) { $data = $request-&gt;only(&apos;username&apos;, &apos;password&apos;); if (Auth::guard(&apos;admin&apos;)-&gt;attempt($data, $remember)) { return redirect(&apos;admin/index/index&apos;); } return redirect(&apos;admin/login/index&apos;)-&gt;withInput($request-&gt;except(&apos;password&apos;))-&gt;with(&apos;msg&apos;, &apos;用户名或密码错误&apos;); } 当然，如果你的网站只有后台管理员不涉及到前台用户，那么在auth.php里可修改默认配置： &apos;defaults&apos; =&gt; [ &apos;guard&apos; =&gt; &apos;admin&apos;,//将默认改为admin &apos;passwords&apos; =&gt; &apos;users&apos;, ], 这样在调用的时候不用指定guard： Auth::attempt($data, $remember)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"模板继承","slug":"模板继承","permalink":"http://yoursite.com/tags/模板继承/"},{"name":"登陆验证","slug":"登陆验证","permalink":"http://yoursite.com/tags/登陆验证/"},{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/中间件/"}]},{"title":"Docker使用（Windows系统）","slug":"Docker使用（Windows系统）","date":"2018-03-23T06:46:56.000Z","updated":"2018-03-23T06:50:29.792Z","comments":true,"path":"2018/03/23/Docker使用（Windows系统）/","link":"","permalink":"http://yoursite.com/2018/03/23/Docker使用（Windows系统）/","excerpt":"","text":"首先从Docker官网上面下载最新版本点击前往 安装过程可能会有点长，因为需要在线下载很多文件。 安装好了之后桌面上会出现一个这样的图标： 双击之后出现running就ok了 然后打开命令提示符输入： docker version PS C:\\WINDOWS\\system32&gt; docker version Client: Version: 17.12.0-ce API version: 1.35 Go version:go1.9.2 Git commit:c97c6d6 Built: Wed Dec 27 20:05:22 2017 OS/Arch: windows/amd64 Server: Engine: Version: 17.12.0-ce API version: 1.35 (minimum version 1.12) Go version: go1.9.2 Git commit: c97c6d6 Built:Wed Dec 27 20:12:29 2017 OS/Arch: linux/amd64 Experimental: true 会出现很多版本相关信息。 PS C:\\WINDOWS\\system32&gt; docker images //查看当前已有镜像 REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 2d194b392dd1 32 hours ago195MB docker4w/nsenter-dockerdlatest cae870735e91 4 months ago187kB registry.cn-hangzhou.aliyuncs.com/diligentyang/centos6.7_nginx_1.10_php5.6.29 v1.0072258802250 14 months ago 854MB 关于镜像可以使用命令： docker search centos 来查找与centos相关的镜像 PS C:\\WINDOWS\\system32&gt; docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 4079[OK] ansible/centos7-ansibleAnsible on Centos7 105 其中越靠前是STARS越多，相当于使用的人最多，当我们选择了一个镜像后查看它的AUTOMATED就能直接拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/diligentyang/centos6.7_nginx_1.10_php5.6.29:v1.0 这里使用的是一个阿里云搭建的php5.6+nginx1.10的镜像 $ docker run -p 80:80 --name ali -it 5a7e /bin/bash docker run ：创建一个新的容器并运行一个命令，常用参数: -i: 以交互模式运行容器，通常与 -t 同时使用； -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用 –name=”nginx-lb”: 为容器指定一个名称； -P 将容器的80端口映射到主机随机端口。 -p 80:80 将容器的80端口映射到主机的80端口 -v 映射主机目录和容器目录 其中 5a7e为镜像的IMAGE ID 如果出现报错的情况： $ docker run -p 80:80 --name ali -it 5a7e /bin/bash cannot enable tty mode on non tty input 总结出两条解决方案 1: 在命令前面加上winpty2: 首先执行 docker-machine ssh default 不出意外的话就能直接进入到镜像了 [root@ec600fcf672e /]# ls bin dev home lib64 lost+found mnt opt root selinux sys usr boot etc lib local media mysql-community-release-el7-5.noarch.rpm proc sbin srv tmp var 该镜像已经配置好了php环境，所以我们只需要： [root@ec600fcf672e /]# php-fpm [root@ec600fcf672e /]# service nginx 就能启动了 在浏览器地址栏输入localhost 或者你的内网ip如果出现phpinfo的相关信息就说明启动成功。 其中网站根目录为 /var/www 如果想退出这个容器（在后台运行）需要按下ctrl+p ctrl+q （偶尔会失效。。） 如果想要切回去继续工作只需要docker attach 容器id（可以为前几位，只要和别的区分开就好） 查看所有容器： PS C:\\WINDOWS\\system32&gt; docker ps -a CONTAINER IDIMAGE COMMAND CREATED STATUS PORTS NAMES ec600fcf672e0722&quot;/bin/bash&quot; About an hour ago Up About an hour 0.0.0.0:80-&gt;8 tcp ali fe985915775ecentos &quot;ls&quot;6 hours ago Exited (0) 6 hours ago 删除不用的容器 docker rm 容器id 如果容器正在运行可以使用docker stop 容器id，关闭容器后再删除。或者直接使用docker rm -f 容器id 删除镜像 docker rmi 镜像id 那么如何将本地目录映射到容器里进行调试呢 可以在启动容器的加上一个-v参数，映射主机目录和容器目录 docker run -p 80:80 --name test -v /e/wamp/www:/var/www -it ec60 /bin/bash 由于我们之前已经配置并启动了镜像，那么我们可以将本地的项目拷贝到容器里： $ docker cp /e/wamp/www/test ec60:/var/www 注意项目的路径写法。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Thinkphp+jquery实现多图异步上传","slug":"Thinkphp-jquery实现多图异步上传","date":"2018-03-23T06:43:35.000Z","updated":"2018-03-23T06:46:23.864Z","comments":true,"path":"2018/03/23/Thinkphp-jquery实现多图异步上传/","link":"","permalink":"http://yoursite.com/2018/03/23/Thinkphp-jquery实现多图异步上传/","excerpt":"","text":"网上查找了很多方法，有的多图上传是通过html添加多个input框type=file，然后在后台遍历循环$_FILES实现一张张上传图片。还有一种就是通过jq将图片转码成base64来将图片存储成字符串的形式，然后后台将获取到的字符串通过解码成图片文件保存，这里要说的就是这种方法。 html页面主要部分如下： &lt;div class=&quot;weui-cells weui-cells_form&quot; id=&quot;uploader&quot;&gt; &lt;div class=&quot;weui-cell&quot;&gt; &lt;div class=&quot;weui-cell__bd&quot;&gt; &lt;div class=&quot;weui-uploader&quot;&gt; &lt;input name=&quot;goods_id&quot; value=&quot;{$goods_id}&quot; type=&quot;hidden&quot;&gt; &lt;div class=&quot;weui-uploader__bd&quot;&gt; &lt;ul class=&quot;weui-uploader__files&quot; id=&quot;uploaderFiles&quot;&gt;&lt;/ul&gt; &lt;div class=&quot;weui-uploader__input-box&quot;&gt; &lt;div class=&quot;file-img&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;p&gt;添加图片&lt;/p&gt; &lt;/div&gt; &lt;input id=&quot;uploaderInput&quot; class=&quot;weui-uploader__input&quot; name=&quot;img&quot; type=&quot;file&quot; accept=&quot;image/*&quot; capture=&quot;camera&quot; multiple=&quot;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; jq部分： /* 图片手动上传 */ var uploadCustomFileList = []; var uploadCount = 0; weui.uploader(&apos;#uploader&apos;, { // url: &apos;http://localhost:8002/upload&apos;, auto: false, type:&apos;base64&apos;, onQueued: function onQueued() { uploadCustomFileList.push(this); //console.log(this.url.match(/url\\((.*?)\\)/)[1].replace(/&quot;/g, &apos;&apos;)); }, onBeforeQueued: function (files) { // `this` 是轮询到的文件, `files` 是所有文件 if ([&quot;image/jpg&quot;, &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;].indexOf(this.type) &lt; 0) { weui.alert(&apos;请上传图片&apos;); return false; // 阻止文件添加 } if (this.size &gt; 2 * 1024 * 1024) { weui.alert(&apos;请上传不超过2M的图片&apos;); return false; } if (files.length &gt; 3) { // 防止一下子选择过多文件 weui.alert(&apos;最多只能上传3张图片，请重新选择&apos;); return false; } if (uploadCount + 1 &gt; 3) { weui.alert(&apos;最多只能上传3张图片&apos;); return false; } ++uploadCount; //return true; // 阻止默认行为，不插入预览图的框架 }, }); 将上传的图片转码成base64 // 缩略图预览 document.querySelector(&apos;#uploaderFiles&apos;).addEventListener(&apos;click&apos;, function (e) { var target = e.target; // var _that = this.children.length; // console.log(_that); while (!target.classList.contains(&apos;weui-uploader__file&apos;) &amp;&amp; target) { target = target.parentNode; } if (!target) return; var url = target.getAttribute(&apos;style&apos;) || &apos;&apos;; var id = target.getAttribute(&apos;data-id&apos;); if (url) { url = url.match(/url\\((.*?)\\)/)[1].replace(/&quot;/g, &apos;&apos;); } var gallery = weui.gallery(url, { onDelete: function onDelete() { weui.confirm(&apos;确定删除该图片？&apos;, function () { var index; for (var i = 0, len = uploadCustomFileList.length; i &lt; len; ++i) { var file = uploadCustomFileList[i]; if (file.id == id) { index = i; break; } } if (index !== undefined) uploadCustomFileList.splice(index, 1); uploadCount --; target.remove(); gallery.hide(); }); } }); }); 这是生成缩略图预览 $(function () { $(&quot;form&quot;).submit(function(){ var arr=[]; var urls=$(&quot;[name=upload_url]&quot;).val(); $(&quot;#uploaderFiles&quot;).find(&quot;li&quot;).each(function(index,item){ var data_id = $(item).data(&quot;id&quot;); var img_url = $(item)[0].style.backgroundImage.split(&quot;\\&quot;&quot;)[1]; //.split(&quot;\\&quot;&quot;)[1] arr[index]=img_url; //console.log(data_id); //console.log(img_url); }) $.ajax({ type:&apos;post&apos;, url:urls, async:false, data:{result:arr}, success:function(msg){ console.log(msg); } }) console.log(arr); return false; }); }) 以上是将转码成base64的图片存到一个二维数组里面，方便后台遍历存储。 jquery传递的数据大致如下： 这是传递两个图片的例子，当只有一个图片的时候二维数组的长度（length）即为1。 后台接收处理图片： /** * 异步上传图片 */ public function upload_img() { if (IS_AJAX) { $data = I(&quot;result&quot;); foreach ($data as $key =&gt; $value) { list($type, $datas) = explode(&apos;,&apos;, $value);//获取图片类型，以及转码后的图片 if (strstr($type, &apos;image/jpeg&apos;) !== &apos;&apos;) {//判断图片类型 $ext = &apos;.jpg&apos;; } elseif (strstr($type, &apos;image/gif&apos;) !== &apos;&apos;) { $ext = &apos;.gif&apos;; } elseif (strstr($type, &apos;image/png&apos;) !== &apos;&apos;) { $ext = &apos;.png&apos;; } $photo = __ROOT__ . &quot;/uploads/Goods/&quot; . date(&quot;Y-m-d&quot;, time()) . &apos;/&apos; . time() . $key . $ext;//生成图片地址和文件并加上图片后缀 // 生成文件 file_put_contents($photo, base64_decode($datas), true);//解码图片进行保存 } $this-&gt;ajaxReturn(&quot;ok&quot;); } } 接收到的数据就是一个二维数组，内容类似： [&quot;data:image\\/jpeg;base64,\\/9j\\/4AAQSkZJRgABgk..&quot;,data:image\\/jpeg;base64,\\/9j\\HBwYIChAKCgk..&quot;] 大概就是二维数组中的每个数组都是一个很长的字符串，其中base64后面就是经转码后的图片。我们要做的就是将图片还原然后保存。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"tp","slug":"tp","permalink":"http://yoursite.com/tags/tp/"}]},{"title":"Mysql相关小技巧总结在这里","slug":"Mysql相关小技巧总结在这里","date":"2018-03-23T06:42:47.000Z","updated":"2018-03-23T06:43:12.083Z","comments":true,"path":"2018/03/23/Mysql相关小技巧总结在这里/","link":"","permalink":"http://yoursite.com/2018/03/23/Mysql相关小技巧总结在这里/","excerpt":"","text":"1.Mysql触发器 适用案例，删除订单同时删除订单详情： CREATE TRIGGER del_orderdetails AFTER DELETE ON ms_order FOR EACH ROW BEGIN DELETE FROM ms_order_details WHERE user_id=old.id; END del_orderdetails：触发器的名称 AFTER：触发时机，为BEFORE或者AFTER DELETE：触发事件，为INSERT、DELETE或者UPDATE ms_order：表示建立触发器的表明，就是在哪张表上建立触发器","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"一些小问题将全部总结在这里","slug":"一些小问题将全部总结在这里","date":"2018-03-23T06:41:06.000Z","updated":"2018-03-23T06:41:35.474Z","comments":true,"path":"2018/03/23/一些小问题将全部总结在这里/","link":"","permalink":"http://yoursite.com/2018/03/23/一些小问题将全部总结在这里/","excerpt":"","text":"1.使用TP3.2.3将项目部署到线上出现Undefined class constant ‘MYSQL_ATTR_INIT_COMMAND’的情况 是因为php没有开启Mysqlnd扩展，php5以上版本已经在使用mysqlnd驱动而非mysql，至于mysqlnd可自行百度了解。且在php7则正式移除了mysql扩展。 在使用phpinfo()打印php信息的时候并没有显示mysqlnd扩展 yum install php70w-mysqlnd systemctl restart php-fpm 网上搜了很久，也折腾了很久，最后发现直接安装mysqlnd扩展，并重启php，再次打印phpinfo()将出现以下内容： 证明已经成功开启mysqlnd扩展，解决了之前出现的问题。 2.FQ 常用的有Lantern（蓝灯），还有火狐浏览器的一个好用的插件Hoxx VPN Proxy","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"PHP无极分类递归方法实现","slug":"PHP无极分类递归方法实现","date":"2018-03-23T06:36:44.000Z","updated":"2018-03-23T06:39:36.176Z","comments":true,"path":"2018/03/23/PHP无极分类递归方法实现/","link":"","permalink":"http://yoursite.com/2018/03/23/PHP无极分类递归方法实现/","excerpt":"","text":"在做权限相关模块的功能，我们需要给不同的用户指定不同功能权限。 首先我们需要一张分类的表格。类似于这样： 其中category_id表示的是分类id，category_name表示的是分类名，pid代表的就是父级分类id，我们可以将顶级的pid设置为0，以递归算法实现父级以下包涵所有子级： /** * 无极分类递归 选择权限 * @param int $assortPid 要查询分类的父级id * @param mixed $tag 上下级分类之间的分隔符 * @param array $list包涵权限的数组 * @return string $tree返回的分类树型结构结果 * */ function recursiveAssort($assortPid, $tag = &apos;&apos;,$list) { $assort = M(&apos;category&apos;)-&gt;where(&quot;pid = $assortPid&quot;)-&gt;field(&apos;category_id, category_name&apos;)-&gt;order(&quot;category_id asc&quot;)-&gt;select(); foreach ($assort as $value) { if(in_array($value[&apos;category_id&apos;], $list)){ $tree .= &apos;&lt;li&gt;&apos;.$tag.&apos;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; name=&quot;permission[]&quot; value=&quot;&apos; . $value[&apos;category_id&apos;] . &apos;&quot;&gt;&apos; .&quot;&lt;label for=&apos;role_2&apos;&gt;&quot;.$value[&apos;category_name&apos;].&quot;&lt;/label&gt;&lt;/li&gt;&quot;; $tree .= recursiveAssort($value[&apos;category_id&apos;], $tag.&apos;├ &apos;,$list); }else{ $tree .= &apos;&lt;li&gt;&apos;.$tag.&apos;&lt;input type=&quot;checkbox&quot; name=&quot;permission[]&quot; value=&quot;&apos; . $value[&apos;category_id&apos;] . &apos;&quot;&gt;&apos; .&quot;&lt;label for=&apos;role_2&apos;&gt;&quot;.$value[&apos;category_name&apos;].&quot;&lt;/label&gt;&lt;/li&gt;&quot;; $tree .= recursiveAssort($value[&apos;category_id&apos;], $tag.&apos;├ &apos;,$list); } } return $tree; } 比如 $list=[1,3,4];那么分类id为1,3,4的分类将会自动添加钩中的样式。 相当于先遍历出pid=0的所有顶级菜单，然后再次调用自身查询当前顶级菜单下的子级菜单，以此类推，直到查询结束。同时以字符串拼接的方式存放在$tree里。 以下为工作中改良后的版本，实现的效果如下： 源代码： &lt;li class=&quot;level0&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;i class=&quot;icon-cogs&quot;&gt;&lt;/i&gt; &lt;span class=&quot;title&quot;&gt;基础设置&lt;/span&gt; &lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;sub-menu&quot;&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;i class=&quot;icon-home&quot;&gt;&lt;/i&gt; &lt;span class=&quot;title&quot;&gt;管理中心&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;i class=&quot;icon-globe&quot;&gt;&lt;/i&gt; &lt;span class=&quot;title&quot;&gt;站点配置&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;i class=&quot;icon-user&quot;&gt;&lt;/i&gt; &lt;span class=&quot;title&quot;&gt;管理员&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; 改版后的递归方法： /** * 无极分类递归 菜单加载 * @param int $assortPid 要查询分类的父级id * @param mixed $tag 上下级分类之间的分隔符 * @param array $list包涵权限的数组 * @return string $tree返回的分类树型结构结果 * */ function recursiveAssort_menu($assortPid,$list,$tag = &apos;&lt;li class=&quot;level0&quot;&gt;&apos;,$tag2=&apos;&lt;ul class=&quot;sub-menu&quot;&gt;&apos;,$tag3=&apos;&lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt;&apos;,$tag4=&apos;&lt;/ul&gt;&lt;/li&gt;&apos;) { $assort = M(&apos;category&apos;)-&gt;where(&quot;pid = $assortPid&quot;)-&gt;field(&apos;category_id, category_name,url,icon&apos;)-&gt;order(&quot;category_id asc&quot;)-&gt;select(); foreach ($assort as $value) { if(in_array($value[&apos;category_id&apos;], $list)){ $tree.=$tag; $tree.= &apos;&lt;a href=&quot;&apos;.$value[&apos;url&apos;].&apos;&quot;&gt; &lt;i class=&quot;&apos;.$value[&apos;icon&apos;].&apos;&quot;&gt;&lt;/i&gt;&lt;span class=&quot;title&quot;&gt;&apos;.$value[&apos;category_name&apos;].&apos;&lt;/span&gt;&apos;.$tag3.&apos;&lt;/a&gt;&apos;.$tag2; $tree.= recursiveAssort_menu($value[&apos;category_id&apos;],$list,&apos;&lt;li class=&quot;level1&quot;&gt;&apos;,&apos;&apos;,&apos;&apos;,&apos;&lt;/li&gt;&apos;); $tree.=$tag4; } } return $tree; }","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"递归 php","slug":"递归-php","permalink":"http://yoursite.com/tags/递归-php/"}]},{"title":"Linux下MYSQL开启远程访问权限","slug":"Linux下MYSQL开启远程访问权限","date":"2018-03-23T06:31:52.000Z","updated":"2018-03-23T06:34:04.194Z","comments":true,"path":"2018/03/23/Linux下MYSQL开启远程访问权限/","link":"","permalink":"http://yoursite.com/2018/03/23/Linux下MYSQL开启远程访问权限/","excerpt":"","text":"当在Linux服务器上搭建了LNMP环境后，在服务器端本地可以访问，但是有时候需要本地先创建数据表再上传到服务器，而Linux下Mysql默认安装完成后只有本地访问的权限，需要指定用户设置访问权限才能远程访问该数据库。 首先登陆数据库： mysql -U root -p 输入数据库密码 然后运行以下sql语句： grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;root&apos;; 前面的root代表远程登陆时的用户名，后面的root代表密码，这样设置的是账号为root密码也为root的mysql用户，中间的’%’表示所有ip地址都能远程访问，如果要针对一台机器访问，将‘%’改为对应的ip地址即可访问数据库。 特别提醒不要讲账号密码设置成简单的组合，不然容易被黑。当我按照以上的操作成功远程登陆，过了几天以后。。。。自己创建的数据库不见了，取而代之的是一个名为 “WARNING”的数据库，其中只有一张名为Readme的表，wtf？打开后是一条数据，大致内容是这样的： Your Data is downloaded and backed up on our secured servers. To recover your lost data: Send 0.1 BTC to our BitCoin Address and Contact us by eMail with your server IP Address and a Proof of Payment. Any eMail without your server IP Address and a Proof of Payment together will be ignored. You are welcome 翻译后是这样的： 您的数据已下载并备份在我们的安全服务器上。恢复你丢失的数据：发送0.1 BTC我们的比特币地址的服务器IP地址的电子邮件和付款证明联系我们。任何没有您的服务器IP地址和付款证明的电子邮件都将被忽略。不客气上网查了一下原来是数据库被黑了，因为设置的账号密码太过简单，而且设置的是在所有ip上都能登陆。所以不要为了省事就不限制登陆数据库的ip地址，也不要将远程登陆的用户密码设置的过于简单。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Centos下LNMP环境搭建","slug":"Centos下LNMP环境搭建","date":"2018-03-23T06:24:56.000Z","updated":"2018-03-23T06:34:10.682Z","comments":true,"path":"2018/03/23/Centos下LNMP环境搭建/","link":"","permalink":"http://yoursite.com/2018/03/23/Centos下LNMP环境搭建/","excerpt":"","text":"1,.安装Nginx 添加CentOS 7 Nginx yum资源库 rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm安装： yum -y install nginx启动： systemctl start nginx.service设置开机启动： systemctl enable nginx.servicenginx配置： 默认配置文件在 /etc/nginx/conf.d/default.conf 我们只需要复制一份配置文件来实现根据域名来访问不同的目录 cp default.conf beeasy.conf然后beeasy.conf的配置如下： server_name 即配置的访问域名 root 后面即为访问该域名的根目录 该配置解决了在WordPress框架下修改固定链接后除首页其他页面404的问题。 重启nginx： systemctl restart nginx.service2.安装php7.0 添加CentOS 7 php7 yum资源库 rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm安装： yum install php70w php70w-opcacheyum install php70w-fpm php70w-opcacheyum install php70w-mysql你也可以安装一些其他扩展： yum install yum-plugin-replaceyum replace php-common –replace-with=php70w-common还包涵一些其他的扩展包，可以根据需求安装： php70w-dba，php70w-devel，php70w-embedded，php70w-enchant，php70w-gd，php70w-pdo等。。 可参考https://webtatic.com/packages/php70/ 3.安装mysql yum -y install mysql安装mysql-server yum -y install mysql-server虽然可能会报错，但是不要慌 wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server然后需要确定几次，都按y回车即可 安装mysql扩展包： yum -y install mysql-connector-odbc mysql-devel libdbi-dbd-mysql重启对应服务： service mysqld restart service php-fpm start service nginx restart初次安装mysql是没有密码的,我们要设置密码，mysql的默认账户为root 设置 MySQL 数据 root 账户的密码： 命令： mysql_secure_installation当出现如下提示时候直接按回车： Enter current password for root出现如下再次回车： Set root password? [Y/n]出现如下提示输入你需要设置的密码，这里输入了root,输入密码是不显示的，回车后再输入一次确认： Remove anonymous users? [Y/n]Disallow root login remotely? [Y/n]Remove test database and access to it? [Y/n]Reload privilege tables now? [Y/n]以上的教程都是搭建完成以后写的，如果存在问题，还请指出。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"mysql nginx php","slug":"mysql-nginx-php","permalink":"http://yoursite.com/tags/mysql-nginx-php/"}]},{"title":"Centos7 配置https协议","slug":"Centos7-配置https协议","date":"2018-03-23T06:20:03.000Z","updated":"2018-03-23T06:34:18.603Z","comments":true,"path":"2018/03/23/Centos7-配置https协议/","link":"","permalink":"http://yoursite.com/2018/03/23/Centos7-配置https协议/","excerpt":"","text":"本文用的是Let’s Encrypt数字证书认证机构免费提供的ssl证书。letsencrypt基于ACME协议自助颁发证书的过程由letsencrypt提供一个工具完成，工具名称现在叫做：certbot，在linux下certbot工具安装后也就是certbot命令。 1,.安装certbot用于生成证书 ##安装epel-release扩展包 yum install epel-release ##更新yum缓存 yum makecache ##直接yum安装certbot yum install certbot 2.使用certbot申请Let’s Encrypt免费的ssl证书 配置Let’s Encrypt有两种模式，standalone和webroot。至于两种模式的区别可自行百度一下。我们这里使用的是webroot模式。 ##--webroot指定你的网站的根目录 certbot certonly --webroot -w /var/www/blog -d blog.ibeeasy.cn 对于nginx而言web根目录下的隐藏目录默认情况下是不允许访问的，所以nginx情况下再执行非standalone模式申请ssl证书之前，需要将nginx网站根目录下的.well-known隐藏目录设置成允许访问。 申请过程中可能会需要输入邮箱接受通知，还有一个同意协议的选项，选y。 不出意外的话，证书文件会在以下的位置： /etc/letsencrypt/live/你的域名/ 3.配置nginx 以前我们使用的是80（http）端口，而https协议是443端口，所以我们要将80端口转发到443端口，在你当前网站的配置文件里修改配置如下： server{ listen 80; server_name blog.ibeeasy.cn; rewrite ^(.*) https://$server_name$1 permanent; } server { listen 443 ssl http2; server_name blog.ibeeasy.cn; #告诉浏览器当前页面禁止被frame add_header X-Frame-Options DENY; #告诉浏览器不要猜测mime类型 add_header X-Content-Type-Options nosniff; #证书路径 ssl_certificate /etc/letsencrypt/live/blog.ibeeasy.cn/fullchain.pem; #私钥路径 ssl_certificate_key /etc/letsencrypt/live/blog.ibeeasy.cn/privkey.pem; #安全链接可选的加密协议 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #可选的加密算法,顺序很重要,越靠前的优先级越高. ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:HIGH:!RC4-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH; #在 SSLv3 或 TLSv1 握手过程一般使用客户端的首选算法,如果启用下面的配置,则会使用服务器端的首选算法. ssl_prefer_server_ciphers on; #储存SSL会话的缓存类型和大小 ssl_session_cache shared:SSL:10m; #缓存有效期 ssl_session_timeout 60m; #其他配置照原先的不变，这里就不列出来了 } 配置完成后重启Nginx或重新加载配置： #或重启nginx systemctl restart nginx #重新加载配置 systemctl reload nginx 至此，https协议就部署完成了，如果还是无法访问，请确定443端口是否开启，或者是否添加安全组443端口的入方向。 4.添加脚本执行证书更新 因为ssl证书的有效期是90天，所以我们要设置一个定时任务来自动更新证书，证书更新的命令如下： ./letsencrypt-auto renew 如果要指定更新某个域名的证书, 则要使用 certonly 参数,： ./letsencrypt-auto certonly --webroot --renew-by-default --email admin@ibeeasy.cn -w /var/www/blog -d blog.ibeeasy.cn -d a.ibeeasy.cn 当然，官方也提供了 cron 运行脚本的方式可以实现定时续期，脚本如下： #!/bin/sh #停止 nginx 服务,使用 --standalone 独立服务器验证需要停止当前 web server. systemctl stop nginx if ! /path/to/letsencrypt-auto renew -nvv --standalone &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; then echo Automated renewal failed: cat /var/log/letsencrypt/renew.log exit 1 fi #启动 nginx systemctl start nginx 将以上脚本保存为 letsencrypt-renew.sh 添加可执行权限： chmod +x letsencrypt-renew.sh 编辑 crontab 配置文件或执行crontab -e 添加 cron 任务： nano /etc/crontab 我这里设置为每月1号0点执行此脚本. #分 时 日 月 星期 执行用户 执行命令 0 0 1 * * root/脚本目录/letsencrypt-renew.sh 加入后Ctrl+X保存退出即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"}]},{"title":"Linux服务器搭建vsftp","slug":"Linux服务器搭建vsftp","date":"2018-03-23T04:03:16.000Z","updated":"2018-03-23T06:30:00.577Z","comments":true,"path":"2018/03/23/Linux服务器搭建vsftp/","link":"","permalink":"http://yoursite.com/2018/03/23/Linux服务器搭建vsftp/","excerpt":"","text":"之前一直用的是windows下的FlashFXP，现在用的Linux服务器（Centos 7.1），为了方便上传项目，安装vsftpd。 1.安装vsftpd yum -y install vsftpd 安装完毕后可以通过启动来测试是否安装完成 systemctl start vsftpd.service 2.创建宿主用户及分配权限 安装完默认情况下是开启匿名登录的，对应的是 /var/ftp 目录，这时只要服务启动了，就可以直接连上FTP了。而这并不是我们想要的效果，一般都是按照需求来分配用户访问不同的目录。 新建一个ftp的宿主用户(即存在Linux系统的用户，不是虚拟用户) groupadd ftpuser #创建用户组 useradd -g root -M -d /var/www -s /sbin/nologin ftpuser #创建系统用户分配权限，只用于ftp，所以禁止登陆系统 passwd ftpuser #设置账户密码，这个不是很重要 #此处的ftpuser就是你的账户名 chown -R ftpuser.root /var/www #把 /var/www 的所有权给ftpuser.root #这里的 /var/www 就是ftp的根目录，没有的话自行创建，也可以换成其他目录 这样就可以通过ftpuser用户连接FTP了。至于虚拟用户需要做的步骤就比较多了。首先虚拟用户的用户认证是通过pam方式去认证的，pam文件里面指定了认证的db文件，db文件又是通过明文用户名和密码文件生成而来，在 /etc/vsftpd/vsftpd.conf 配置文件是通过 pam_service_name=vsftpd 配置指定的，其位置是 /etc/pam.d/vsftpd，编辑该文件，把文件内容全部注释掉，加上以下两行： 64位系统： auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser_passwd account required /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser_passwd 32位系统： auth sufficient /lib/security/pam_userdb.so db=/etc/vsftpd/vuser_passwd account sufficient /lib/security/pam_userdb.so db=/etc/vsftpd/vuser_passwd db=/etc/vsftpd/vuser_passwd 指定了db文件的位置，接下来就是生成db文件，由于db文件是通过明文用户名和密码文件生成而来，所以先创建一个保存明文用户名和密码的文件 vuser_passwd.txt vi /etc/vsftpd/vuser_passwd.txt 这个文件的奇数行位账号，偶数行为密码： beeasy beeasy1234 保存之后通过以下命令生成db文件： cd /etc/vsftpd db_load -T -t hash -f vuser_passwd.txt vuser_passwd.db 如果 db_load 命令无法使用，那就需要安装db4 包 yum -y install db4 如果要添加新的用户的话，在 vuser_passwd.txt 文件里面继续添加用户密码，但是要再次生成一下db文件。然后现在每个用户的具体配置是通过一个用户对应一个配置文件来实现的，且这个文件必须用FTP用户名去做文件名，建一个目录专门存放这些文件： 在vsftpd目录下 mkdir vuser_conf 并且新建文件 vi vuser_conf/beeasy 大致内容如下： local_root 是指当前虚拟用户的访问目录 write_enable 设置用户是否可以写入 anon_upload_enable 设置虚拟用户的上传功能 anon_mkdir_write_enable 设置虚拟用户创建文件夹的功能 anon_other_write_enable 设置虚拟用户是否可以执行其他的写入操作，覆盖，删除，重命名等。 max_per_ip 最多允许同一账户在多少个不同的ip登陆 3.根据以上的信息来修改vsftpd的配置文件 anonymous_enable=NO # 禁用匿名登录 ascii_upload_enable=YES ascii_download_enable=YES chroot_local_user=YES # 启用限定用户在其主目录下 以下配置为自己添加： 然后重启vsftpd： systemctl restart vsftpd.service 若是连接超时，请确认防火墙是否开放vsftpd服务的端口，建议开放20至22号端口以及主动模式PASV下的6000至7000端口。或者在服务器上的安全组里添加入方向的端口。 以及SElinux是否关闭。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-03-23T01:25:30.070Z","updated":"2018-03-23T01:25:30.070Z","comments":true,"path":"2018/03/23/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}